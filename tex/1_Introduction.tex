Modal logics have been widely studied in Computer Science for allowing the
characterization of complex systems that express notions in terms of knowledge,
belief etc. Once a system has been specified in a logic language, it is possible
to use proof methods to verify properties of such systems. In the literature,
there are several theorem provers for modal logics.  In this work, we focus on
\ksp~\cite{Nalon2016}, a theorem prover for the basic multimodal language
\system{K}{n}{}, which implements the clausal resolution method proposed
in~\cite{nalon2015modal}.  Clauses are labelled by the modal level at which they
occur, helping to restrict unnecessary applications of the resolution inference
rules. Several refinements and simplification techniques in order to reduce the
search space for a proof are implemented. To get the best performance for a
particular formula, or class of formulae, it is important to choose the right
strategy and optimizations. Currently, \ksp~leaves these choices to the user, so
we are interested in steps towards the implementation of an ``auto-mode'' in
which the prover makes choices on its own, based on an analysis of the input.

\ksp~performs well if the set of propositional symbols are uniformly distributed
over the modal levels. However, when there is a high number of propositional
symbols in just one particular level, the performance deteriorates. One reason
is that the specific normal form we use always generates satisfiable sets of
propositional clauses (i.e.\ clauses without modal operators). As resolution
relies on saturation, this can be very time consuming. We are currently
investigating the use of other tools in order to speed up the saturation
process. For instance, \emph{Boolean Satisfiability Solvers} can often solve
hard structured problems with over a million variables and several million
constraints~\cite{satchapter}. We believe that we can take advantage of the
theoretical and practical efforts that have been directed in improving the
efficiency of such solvers. 

Our implementation, which is work in progress, uses a SAT solver based on clause
learning by conflict analysis. We feed this solver with the satisfiable sets of
clauses generated and, each time it identifies a conflict in these sets due to
unit propagation from some variable assignment, one or more new clauses are
learnt from the conflict analysis procedure, which analyses the structure of
unit propagation and decides which literals to include in the new
clauses~\cite{cdclchapter}. As mentioned before, as we already know that these
sets are satisfiable, we are not particularly interested in the model generated
by the SAT solver, but we believe that by carefully choosing the set of clauses
and making use of the learnt clauses generated by MiniSat we may be able to
reduce the time \ksp~spends during saturation. 

