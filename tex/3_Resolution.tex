%\section{}
Resolution appeared in the early 1960's through investigations on performance
improvements of refutational procedures based on \emph{Herbrand Theorem}. In
particular, Prawitz' studies on such procedures brought back the idea of
unification. J.~A.~Robinson incorporated the concept of unification on a
refutation method, creating what was later known as resolution~\cite{casanova}. 

The standard rule for resolution systems takes two or more premises with
literals that are contradictory, and generates a resolvent. Most of these systems
work exclusively with clauses in a specific normal form. Resolution systems are
refutational systems, that is, to show that a formula \formula~is valid, $\neg
\formula$ is translated into a normal form. The inference rules are applied
until either no new resolvents can be generated or a contradiction is obtained.
The contradiction implies that $\neg \formula$ is unsatisfiable and hence, that
\formula~is valid.

%, for propositional
%logic, contains only one inference rule, which originates a new clause from two
%existing ones.

\section{Clausal Resolution}

Clausal resolution was proposed as a proof method for classical logic by
Robinson in 1965~\cite{Robinson65}, and was claimed to be suitable to be
performed by computer, as it has only one inference rule that is applied
exhaustively. 

%Nonclausal proof methods, in general, require a larger number of rules, making
%implementation more difficult. Clausal resolution is a simple and adaptable
%proof method for classical logics and, since it was proposed, a bank of research
%into heuristics and strategies has been growing. 

%\subsection{Substitution}

%\subsection{Unification}

%\subsection{The resolution principle}

\section{Separated Normal Form with Modal Levels}

Formulae in \system{K}{n}{} can be transformed into a layered normal form called
\emph{Separated Normal Form with Modal Levels}, denoted by
\snf{$ml$}, proposed in~\cite{journals/jal/NalonD07}. A formula in \snf{$ml$} is a
conjunction of \emph{clauses} where the modal level in which they occur is
emphasized as a label.

We write $ml: \formula$ to denote that \formula~occurs at modal level $ml\in
\Nat \cup \{*\}$. By $*: \formula$ we mean that \formula~is true at
all modal levels. Formally, let $\wffml$ denote the set of formulae with
the modal level annotation, $ml : \formula$, such that $ml \in \Nat \cup \{*\}$
and $\formula \in \wff$. Let $\Model^* = (W, \st_0, R_1, \ldots, R_n, R_*, \pi)$
be a tree-like model and take $\formula \in \wff$. 

\begin{definition}
Satisfiability of labelled formulae is given by:

\begin{enumerate}
    \item $\Model^* \models ml : \formula$ if, and only if, for all worlds
        $\st \in W$ such that $depth(\st) = ml$, we have
        \sat{\Model^*}{\st}{\formula} 
    \item $\Model^* \models * : \formula$ if, and only if, $\Model^* \models
        \nec{*} \formula$
\end{enumerate}
    
\end{definition}

Observe that the labels in formulae work as a kind of \textit{weak} universal
operator, allowing us to reason about a set of formulae that are all satisfied
at a given modal level.

Clauses in \snf{$ml$} are defined as follows.

\begin{definition}
    Clauses in \snf{$ml$} are in one of the following forms:
    \begin{enumerate}
        \item Literal clause $\ \ \quad \qquad ml : \bigvee^r_{b=1} l_b$
        \item Positive $a$-clause $\ \qquad ml : l' \then \nec{a} l$
        \item Negative $a$-clause $\qquad ml : l' \then \pos{a} l$
    \end{enumerate}
    where $r, b \in \Nat, ml \in \Nat \cup \{*\}$ and $l, l', l_b \in
    \Literals$.
\end{definition}

Positive and negative $a$-clauses are together known as \emph{modal
$a$-clauses}, the index $a$ can be omitted if it is clear from the context.

The transformation of a formula $\formula \in \wff$ into \snf{$ml$} is achieved
by first transforming $\formula$ into its \emph{Negation Normal Form}, and then,
recursively applying rewriting and renaming~\cite{plaisted1986structure}.

\begin{definition}
    Let $\formula \in \wff$. We say that $\formula$ is in Negation Normal Form (NNF) if
    it contains only the operators $\neg, \lor, \land, \nec{a}$ and $\pos{a}$. Also,
    only propositions are allowed in the scope of negations.
\end{definition}

Let $\formula$ be a formula and $t$ a propositional symbol not occurring in
$\formula$. The translation of $\formula$ is given by $0 : t \land \rho(0 : t
\then \formula)$ -- for global satisfiability, the translation is given by $* :
t \land (\rho(* : t \then \formula)$ -- where $\rho$ is the \emph{translation
function} defined below. We refer to clauses of the form $0 : D$, for a
disjunction of literals $D$, as \emph{initial clauses}. 

\begin{definition}
    The translation function $\rho : \wffml \longrightarrow \wffml$ is defined
    as follows:
        \begin{align*}
            \rho(ml : t \then \formula \land \psi) & = \rho(ml : t \then \formula) \land \rho(ml : t \then \psi) \\
            \rho(ml : t \then \nec{a} \formula) & = (ml : t \then \nec{a} \formula) \text{, if \formula\ is a literal}\\
                                                & = (ml : t \then \nec{a} t') \land \rho(ml+1 : t' \then \formula) \text{, otherwise}\\
            \rho(ml : t \then \pos{a} \formula) & = (ml : t \then \pos{a} \formula) \text{, if \formula\ is a literal}\\
                                                & = (ml : t \then \pos{a} t') \land \rho(ml+1 : t' \then \formula) \text{, otherwise}\\
            \rho(ml : t \then \formula \lor \psi) & = (ml : \neg t \lor \formula
            \lor \psi) \text{, if $\psi$ is a disjunction of literals}\\
                                                  & = \rho(ml : t \then \formula \lor t') \land \rho(ml : t' \then \psi) \text{, otherwise}
        \end{align*}
        Where $t, t' \in \Literals$, $\formula, \psi \in \wff$, $ml \in
        \Nat \cup \{*\}$ and $r, b \in \Nat$.
\end{definition}

As the conjunction operator is commutative, associative and idempotent, we will
commonly refer to a formula in \snf{$ml$} as a set of clauses.

The next lemma, taken from~\cite{nalon2015modal}, shows that the transformation
into \snf{$ml$} preserves satisfiability.

\begin{lemma}
    Let $\formula \in \wff$ be a formula and let $t$ be a propositional symbol
    not occurring in $\formula$. Then: 
    \begin{enumerate}
        \item[$(i)$] $\formula$ is satisfiable if, and only if, $0 : t \land \rho(0 : t \then \formula)$ is satisfiable;
        \item[$(ii)$] $\formula$ is globally satisfiable if, and only if, $* : t \land \rho(* : t \then \formula)$ is satisfiable;
    \end{enumerate}
\end{lemma}

\begin{example}
    
\end{example}
