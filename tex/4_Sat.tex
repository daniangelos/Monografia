%\section{}
The problem of determining whether a formula in classical propositional logic is
satisfiable has the historical honor of being the first problem ever shown to be
NP-Complete~\cite{Cook}. Great theoretical and practical efforts have been
directed in improving the efficiency of solvers for this problem, known as
\emph{Boolean Satisfiability Solvers}, or just \emph{SAT solvers}. Despite the
worst-case exponential run time of all the algorithms known, satisfiability
solvers are increasingly leaving their mark as a general purpose tool in the
most diverse areas~\cite{satchapter}. In essence, SAT solvers provide a generic
combinatorial reasoning and search platform. 

In the context of SAT solvers for propositional provers, the underlying
representational formalism is propositional logic~\cite{satchapter}. We are
interested in formulae in \emph{Conjunctive Normal Form} (CNF): $\formula$ is in
CNF if it is a conjunction of \emph{clauses}, where each clause is a disjunction
of literals. For example, $\formula = (p \lor \neg q) \land (\neg p \lor r \lor
s) \land (q \lor r)$ is a CNF formula with four literals and three clauses. 
We use the symbol $\emptyset$ to denote the \emph{empty clause}, i.e., the
clause that contains no literals. A clause with only one literal is referred to
as a \emph{unit clause}, and a clause with two literals, as a \emph{binary
clause}.  When every clause of $\formula$ has $k$ literals, we refer to
$\formula$ as a $k$-CNF formula.  

%% satisfying assignment %%
A propositional formula $\formula$ takes value in the set $\{false, true\}$. A
\emph{truth assignment} (or just assignment) to a set of literals $\Literals$ is
a map $\sigma : \Literals \longrightarrow \{false, true\}$. A \emph{satisfying
assignment} for $\formula$ is an assignment $\sigma$ such that $\formula$
evaluates to $true$ under $\sigma$.  A \emph{partial assignment} for a formula
$\formula$ is a truth assignment to a subset of the literals in $\formula$. For
a partial assignment $\rho$ for a CNF formula $\formula$, $\formula|_\rho$
denotes the simplified formula obtained by replacing the literals appearing in
$\rho$ with their specified values, removing all clauses with at least one
$true$ literal, and deleting all occurrences of $false$ literals from the
remaining clauses.

Therefore, the \emph{Boolean Satisfiability Problem} (SAT) can be expressed as:
Given a CNF formula $\formula$, does $\formula$ have a satisfying assignment? If
this is the case, $\formula$ is said to be \emph{satisfiable}, otherwise,
$\formula$ is \emph{unsatisfiable}.  One can be interested not only in the
answer of this decision problem, but also in finding the actual assignment that
satisfies the formula, when it exists. All practical SAT solvers do produce such
assignment~\cite{cormen}. 

\section{The DPLL Procedure}
\label{sec:dpll}

A \emph{complete} solution method for the SAT problem is one that, given the
input formula $\formula$, either produces a satisfying assignment for $\formula$
or proves that it is unsatisfiable.  One of the most surprising aspects
of the relatively recent practical progress of SAT solvers is that the best
complete methods remain variants of a process introduced in the early 1960â€™s:
the Davis-Putnam-Logemann-Loveland, or DPLL, procedure~\cite{satchapter}, which
performs a backtrack search in the space of partial truth
assignments~\cite{DavisLongemannLoveland:1962}. A key feature of DPLL is efficient pruning
of the search space based on falsified clauses. Since its introduction, the main
improvements to DPLL have been smart branch selection heuristics, extensions
like clause learning and randomized restarts, and well-crafted data structures
such as lazy implementations and watched literals for fast unit
propagation~\cite{satchapter}.

Algorithm~\ref{alg:dpll}, DPLL-recursive$(\formula, \rho)$, sketches the basic
DPLL procedure on CNF formulae~\cite{DavisLongemannLoveland:1962}. The main idea
is to repeatedly select an unassigned literal $l$ in the input formula and
recursively search for a satisfying assignment for $\formula|_l$ and
$\formula|_{\neg l}$. The step where such an $l$ is chosen is called a
\emph{branching step}. Setting $l$ to true or false when making a recursive call
is referred to as \emph{decision}, and is associated with a decision level which
equals the recursion depth at that stage. The end of each recursive call, which
takes $\formula$ back to fewer assigned literals, is called the
\emph{backtracking step}.


\begin{algorithm}[!ht]
    %\SetKwInOut{Input}{Input}
    %\SetKwInOut{Output}{Output}
    %\Input{A CNF formula $\formula$ and an initially empty partial assignment $\rho$}
    %\Output{UNSAT, or an assignment satisfying $\formula$}

    %\underline{function Euclid} $(a,b)$

    $(\formula, \rho) \leftarrow$ UnitPropagate$(\formula,\rho)$

    \If{$\formula$ contains the empty clause}
    {\Return~UNSAT}
    \If{$\formula$ has no clauses left}
    {Output $\rho$\\
    \Return{SAT}
    }
    $l \leftarrow$ a literal not assigned by $\rho$

    \If{DPLL-recursive$(\formula|_l, \rho \cup \{l\}) = $ SAT} 
    {\Return{SAT}}
    \Return{DPLL-recursive$(\formula|_{\neg l}, \rho \cup \{\neg l\})$}
\caption{DPLL-recursive$(\formula, \rho$)}
\label{alg:dpll}
\end{algorithm}

\section{Conflict Driven Clause Learning}
\label{sec:cdcl}

Algorithm~\ref{alg:cdcl}.

\begin{algorithm}[!ht]
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{}
    \Output{}

    \If{UnitPropagate$(F, \nu) == $ CONFLICT}
    {\Return{UNSAT}}

    $dl \leftarrow 0$

    \While{\textbf{not} AllVariablesAssigned$(F, \nu)$}
    {$(x, \nu) \leftarrow$ PickBranchingVariable$(F,\nu)$}

    \Return{SAT}
    \caption{CDCL$(F, \nu)$}
\label{alg:cdcl}
\end{algorithm}

\section{MiniSat and Glucose}
\label{sec:minisat}
Minisat~\cite{minisat}

