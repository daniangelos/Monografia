%\section{}
The problem of determining whether a boolean formula is satisfiable has the
historical honor of being the first problem ever shown to be
NP-Complete~\cite{Cook}. Great theoretical and practical efforts have been directed
in improving the efficiency of solvers for this problem, known as \emph{Boolean
Satisfiability Solvers}, or just \emph{SAT solvers}. Despite the worst-case
exponential run time of all the algorithms known, satisfiability solvers are
increasingly leaving their mark as a general purpose tool in the most diverse
areas~\cite{satchapter}. In essence, SAT solvers provide a generic combinatorial
reasoning and search platform. 

In the context of SAT solvers, the underlying representational formalism is
propositional logic. We are interested in propositional formulae in
\emph{Conjunctive Normal Form} (CNF): $F$ is in CNF if it is a conjunction of
\emph{clauses}, where each clause is a disjunction of \emph{literals}. For
example, $F = (p \lor \neg q) \land (\neg p \lor r \lor s) \land (q \lor r)$ is
a CNF formula with four variables and three clauses.

Therefore, the \emph{Boolean Satisfiability Problem} (SAT) can be expressed as:
Given a CNF formula $F$, does $F$ have a satisfying assignment? One can be
interested not only in the answer of this decision problem, but also in finding
an actual satisfying assignment when it there exists one. All practical SAT
solvers do produce such assignment~\cite{cormen}.

\section{The DPLL Procedure}
\label{sec:dpll}

\begin{algorithm}[!ht]
\label{alg:dpll}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{A CNF formula $F$ and an initially empty partial assignment $\rho$}
    \Output{UNSAT, or an assignment satisfying $F$}

    %\underline{function Euclid} $(a,b)$

    $(F, \rho) \leftarrow$ UnitPropagate$(F,\rho)$

    \If{$F$ contains the empty clause}
    {\Return~UNSAT}
    \If{$F$ has no clauses left}
    {Output $\rho$\\
    \Return{SAT}
    }
    $l \leftarrow$ a literal not assigned by $\rho$

    \If{DPLL-recursive$(F|_l, \rho \cup \{l\}) = $ SAT} 
    {\Return{SAT}}
    \Return{DPLL-recursive$(F|_{\neg l}, \rho \cup \{\neg l\})$}
\caption{DPLL-recursive$(F, \rho$)}
\end{algorithm}

\section{Conflict Driven Clause Learning}
\label{sec:cdcl}

\begin{algorithm}[!ht]
\label{alg:cdcl}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{}
    \Output{}

    \If{UnitPropagate$(F, \nu) == $ CONFLICT}
    {\Return{UNSAT}}

    $dl \leftarrow 0$

    \While{\textbf{not} AllVariablesAssigned$(F, \nu)$}
    {$(x, \nu) \leftarrow$ PickBranchingVariable$(F,\nu)$}

    \Return{SAT}
    
    \caption{CDCL$(F, \nu)$}
\end{algorithm}

\section{MiniSat}
\label{sec:minisat}

