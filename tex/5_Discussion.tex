%\section{}
In Chapter~\ref{3_Resolution}, we've mentioned \ksp, the theorem prover
presented in~\cite{Nalon2016}. \ksp~performs well if the set of propositional
symbols are uniformly distributed over the modal levels. However, when there is
a high number of propositional symbols in just one particular level, the
performance deteriorates. One reason is that the specific normal form we use
always generates satisfiable sets of propositional clauses (clauses
without modal operators). As resolution relies on saturation, this can be very
time consuming. We are currently investigating the use of other tools in order
to speed up the saturation process. 

As we saw in Chapter~\ref{4_Sat}, SAT solvers can often solve hard structured
problems with over a million variables and several million
constraints~\cite{satchapter}. We believe that we can take advantage of the
theoretical and practical efforts that have been directed in improving the
efficiency of such solvers. 

Our implementation, which is work in progress, uses a SAT solver based on clause
learning by conflict analysis. We feed this solver with the satisfiable sets of
clauses generated. Each time a conflict is identified in these sets due to unit
propagation from some variable assignment, one or more new clauses are learnt
from the conflict analysis procedure, that analyses the structure of unit
propagation and decides which literals to include in the new
clauses~\cite{cdclchapter}. As we already know that these sets are satisfiable,
we are not particularly interested in the satisfying assignment generated by the
SAT solver, but we believe that by carefully choosing the set of clauses and
making use of the learnt clauses generated by the solver, we may be able to
reduce the time \ksp~spends during saturation. 

%% Comment on minisat and glucose

\section{Related Work}
In~\cite{giunchiglia2002sat}, Giunchiglia et.\ al.\ present a set of SAT-based
decision procedures for various classical modal logics. These procedures are
built on top of a SAT solver. This differ from our work in the sense that we are
not developing a system from an existing solver. Our implementation instantiates
a SAT solver to feed it with sets we already know are satisfiable.

\section{Future Work}
%%comment on evaluating the tests and the choices
